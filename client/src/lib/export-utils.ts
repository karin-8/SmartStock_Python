import type { InventoryItemWithForecast } from "@shared/schema";

/**
 * Export order details to PDF
 */
export async function exportOrderToPDF(item: InventoryItemWithForecast, quantity: number) {
  try {
    // Dynamically import jsPDF
    const { jsPDF } = await import('jspdf');
    
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 20;
    let yPosition = margin;

    // Header
    doc.setFontSize(20);
    doc.setFont("helvetica", "bold");
    doc.text("SmartStock Purchase Order", pageWidth / 2, yPosition, { align: 'center' });
    
    yPosition += 20;
    
    // Order details
    doc.setFontSize(12);
    doc.setFont("helvetica", "normal");
    
    const orderDate = new Date().toLocaleDateString();
    const expectedDelivery = new Date(Date.now() + item.leadTimeDays * 24 * 60 * 60 * 1000).toLocaleDateString();
    const totalCost = (quantity * item.unitCost).toFixed(2);
    
    const details = [
      `Order Date: ${orderDate}`,
      `Expected Delivery: ${expectedDelivery}`,
      '',
      'ITEM DETAILS:',
      `Item Name: ${item.name}`,
      `SKU: ${item.sku}`,
      `Supplier: ${item.supplier}`,
      `Category: ${item.category}`,
      '',
      'ORDER DETAILS:',
      `Quantity Ordered: ${quantity} units`,
      `Unit Cost: $${item.unitCost.toFixed(2)}`,
      `Total Cost: $${totalCost}`,
      '',
      'INVENTORY METRICS:',
      `Current Stock: ${item.currentStock} units`,
      `Reorder Point: ${item.reorderPoint} units`,
      `Safety Stock: ${item.safetyStock} units`,
      `Weekly Demand: ${item.weeklyDemand.toFixed(1)} units`,
      '',
      'JUSTIFICATION:',
      item.aiInsights.length > 0 ? item.aiInsights[0] : 'Order recommended based on current stock levels and demand patterns.',
    ];
    
    details.forEach(line => {
      if (line.endsWith(':')) {
        doc.setFont("helvetica", "bold");
      } else {
        doc.setFont("helvetica", "normal");
      }
      
      doc.text(line, margin, yPosition);
      yPosition += 7;
      
      if (yPosition > 280) {
        doc.addPage();
        yPosition = margin;
      }
    });
    
    // Footer
    yPosition = 280;
    doc.setFontSize(10);
    doc.setFont("helvetica", "italic");
    doc.text("Generated by SmartStock Inventory Management System", pageWidth / 2, yPosition, { align: 'center' });
    
    // Save the PDF
    doc.save(`purchase-order-${item.sku}-${orderDate.replace(/\//g, '-')}.pdf`);
    
  } catch (error) {
    console.error('Error generating PDF:', error);
    alert('Failed to generate PDF. Please try again.');
  }
}

/**
 * Export order details to Excel
 */
export async function exportOrderToExcel(item: InventoryItemWithForecast, quantity: number) {
  try {
    // Dynamically import xlsx
    const XLSX = await import('xlsx');
    
    const orderDate = new Date().toISOString().split('T')[0];
    const expectedDelivery = new Date(Date.now() + item.leadTimeDays * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    const totalCost = (quantity * item.unitCost).toFixed(2);
    
    // Create workbook data
    const orderData = [
      ['SmartStock Purchase Order', '', '', ''],
      ['', '', '', ''],
      ['Order Information', '', '', ''],
      ['Order Date', orderDate, '', ''],
      ['Expected Delivery', expectedDelivery, '', ''],
      ['', '', '', ''],
      ['Item Details', '', '', ''],
      ['Item Name', item.name, '', ''],
      ['SKU', item.sku, '', ''],
      ['Supplier', item.supplier, '', ''],
      ['Category', item.category, '', ''],
      ['', '', '', ''],
      ['Order Details', '', '', ''],
      ['Quantity Ordered', quantity, 'units', ''],
      ['Unit Cost', `$${item.unitCost.toFixed(2)}`, '', ''],
      ['Total Cost', `$${totalCost}`, '', ''],
      ['', '', '', ''],
      ['Current Inventory Metrics', '', '', ''],
      ['Current Stock', item.currentStock, 'units', ''],
      ['Reorder Point', item.reorderPoint, 'units', ''],
      ['Safety Stock', item.safetyStock, 'units', ''],
      ['Weekly Demand', item.weeklyDemand.toFixed(1), 'units', ''],
      ['Lead Time', item.leadTimeDays, 'days', ''],
      ['', '', '', ''],
      ['AI Insights', '', '', ''],
    ];
    
    // Add AI insights
    item.aiInsights.forEach(insight => {
      orderData.push([insight, '', '', '']);
    });
    
    // Add 8-week forecast
    orderData.push(['', '', '', '']);
    orderData.push(['8-Week Stock Forecast', '', '', '']);
    orderData.push(['Week', 'Week Start', 'Projected Stock', 'Status']);
    
    item.stockStatus.forEach((status, index) => {
      orderData.push([
        `Week ${index + 1}`,
        status.weekStartDate,
        status.projectedStock,
        status.status.toUpperCase()
      ]);
    });
    
    // Create worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(orderData);
    
    // Set column widths
    worksheet['!cols'] = [
      { width: 25 },
      { width: 20 },
      { width: 15 },
      { width: 15 }
    ];
    
    // Style the header
    if (worksheet['A1']) {
      worksheet['A1'].s = {
        font: { bold: true, size: 16 },
        alignment: { horizontal: 'center' }
      };
    }
    
    // Create workbook
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Purchase Order');
    
    // Save the file
    XLSX.writeFile(workbook, `purchase-order-${item.sku}-${orderDate}.xlsx`);
    
  } catch (error) {
    console.error('Error generating Excel file:', error);
    alert('Failed to generate Excel file. Please try again.');
  }
}

/**
 * Export inventory summary to Excel
 */
export async function exportInventorySummary(inventory: InventoryItemWithForecast[]) {
  try {
    const XLSX = await import('xlsx');
    
    // Prepare summary data
    const summaryData = inventory.map(item => ({
      'Item Name': item.name,
      'SKU': item.sku,
      'Current Stock': item.currentStock,
      'Reorder Point': item.reorderPoint,
      'Safety Stock': item.safetyStock,
      'Weekly Demand': parseFloat(item.weeklyDemand.toFixed(1)),
      'Unit Cost': parseFloat(item.unitCost.toFixed(2)),
      'Total Value': parseFloat((item.currentStock * item.unitCost).toFixed(2)),
      'Supplier': item.supplier,
      'Category': item.category,
      'Status': item.currentStock <= item.reorderPoint ? 'LOW STOCK' : 'OK',
      'Weeks Until Reorder': Math.floor((item.currentStock - item.reorderPoint) / item.weeklyDemand),
    }));
    
    // Create worksheet
    const worksheet = XLSX.utils.json_to_sheet(summaryData);
    
    // Set column widths
    worksheet['!cols'] = [
      { width: 25 }, // Item Name
      { width: 12 }, // SKU
      { width: 12 }, // Current Stock
      { width: 12 }, // Reorder Point
      { width: 12 }, // Safety Stock
      { width: 12 }, // Weekly Demand
      { width: 10 }, // Unit Cost
      { width: 12 }, // Total Value
      { width: 15 }, // Supplier
      { width: 15 }, // Category
      { width: 12 }, // Status
      { width: 15 }, // Weeks Until Reorder
    ];
    
    // Create workbook
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Inventory Summary');
    
    // Save the file
    const today = new Date().toISOString().split('T')[0];
    XLSX.writeFile(workbook, `inventory-summary-${today}.xlsx`);
    
  } catch (error) {
    console.error('Error generating inventory summary:', error);
    alert('Failed to generate inventory summary. Please try again.');
  }
}
